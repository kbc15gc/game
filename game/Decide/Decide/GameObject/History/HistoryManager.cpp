#include"stdafx.h"
#include "HistoryManager.h"

#include "GameObject\Village\ContinentObject.h"
#include "GameObject\Village\NPC.h"
#include "fbEngine\_Object\_Component\_Physics\BoxCollider.h"

/** インスタンス. */
HistoryManager* HistoryManager::_Instance = nullptr;

/**
* コンストラクタ.
*/
HistoryManager::HistoryManager()
{
	//CSVから歴史情報読み取り。
	Support::LoadCSVData<LocationHistoryInfo>("Asset/Data/LocationHistory.csv", HistoryInfoData, ARRAY_SIZE(HistoryInfoData), _LocationHistoryList);

	FOR(i, _LocationHistoryList.size())
	{
		//vectorを追加
		vector<GameObject*> list;
		_GameObjectList.push_back(list);
	}

}

/**
* 初期化.
*/
void HistoryManager::Start()
{
	_HistoryMenu = (HistoryMenu*)INSTANCE(GameObjectManager)->FindObject("HistoryMenu");
	_HistoryBook = (HistoryBook*)INSTANCE(GameObjectManager)->FindObject("HistoryBook");
}

/**
* 歴史オブジェクト生成.
*/
void HistoryManager::CreateObject()
{
	FOR(i, _LocationHistoryList.size())
	{
		//歴史のオブジェクト切り替え・生成
		_ChangeLocation((LocationCodeE)i);
	}

	//共通オブジェクト生成
	char* type[2] = { "Obj","NPC" };
	char path[128];
	{		
		//パス生成
		sprintf(path, "Asset/Data/GroupData/CommonGroup%s.csv", type[0]);
		_CreateObject(-1, path);
	}
}

/**
* 歴史を変える.
*
* @param location	場所ID.
* @param slot		スロット番号.
* @param chip		チップID.
*/
bool HistoryManager::SetHistoryChip(LocationCodeE location, UINT slot, ChipID chip)
{
	//ひとまず入れるだけで上書されてしまう.
	_LocationHistoryList[(int)location]->SetChip(chip, slot);
	_HistoryBook->PutInChip(chip);

	//変更したので歴史を改変させる.
	_ChangeLocation(location);

	//データを保存.
	Support::OutputCSV<LocationHistoryInfo>("Asset/Data/LocationHistory.csv", HistoryInfoData, ARRAY_SIZE(HistoryInfoData), _LocationHistoryList);

	return true;
}

/**
* 場所の変化.
*
* @param location	場所ID.
*/
void HistoryManager::_ChangeLocation(LocationCodeE location)
{
	//前のオブジェクトを削除
	for(auto& it : _GameObjectList[(int)location])
	{
		INSTANCE(GameObjectManager)->AddRemoveList(it);
	}
	_GameObjectList[(int)location].clear();

	//チップの状態からグループを計算。
	const int group = _CalcPattern(_LocationHistoryList[(int)location].get());

	char* type[2] = { "Obj","NPC" };
	char path[128];
	
	//OBJ
	{
		//パス生成
		sprintf(path, "Asset/Data/GroupData/Group%c%s.csv", 'A' + group, type[0]);
		_CreateObject((int)location, path);
		
	}
	ZeroMemory(path, 128);
	//NPC
	{
		//パス生成
		sprintf(path, "Asset/Data/GroupData/Group%c%s.csv", 'A' + group, type[1]);
		
		
		//CSVからオブジェクトの情報読み込み
		vector<unique_ptr<NPCInfo>> npcInfo;
		Support::LoadCSVData<NPCInfo>(path, NPCInfoData, ARRAY_SIZE(NPCInfoData), npcInfo);

		//情報からオブジェクト生成。
		FOR(i, npcInfo.size())
		{
			//生成
			NPC* npc = INSTANCE(GameObjectManager)->AddNew<NPC>("NPC", 2);
			npc->LoadModel(npcInfo[i]->filename);
			npc->SetMesseage(npcInfo[i]->MesseageID, npcInfo[i]->ShowTitle);
			npc->transform->SetLocalPosition(npcInfo[i]->pos);
			npc->transform->SetRotation(npcInfo[i]->ang);
			npc->transform->SetLocalScale(npcInfo[i]->sca);
			//管理用の配列に追加。
			_GameObjectList[(int)location].push_back(npc);
		}

		npcInfo.clear();
	}
}

/**
* パターン計算.
*/
int HistoryManager::_CalcPattern(const LocationHistoryInfo * info)
{
	//大陸に合ったグループシート読み込み
	char path[256];
	sprintf(path, "Asset/Data/Village%dGroup.csv", 0/*+ info->ContinentID*/);
	//CSVからグループ情報読み込み
	vector<unique_ptr<VillageGroup>> groupList;
	Support::LoadCSVData<VillageGroup>(path, VillageGroupData, ARRAY_SIZE(VillageGroupData), groupList);
	
	int pattern = 0;
	//一致するものがあるか調べる。
	for(auto& group : groupList)
	{
		bool isMatch = true;
		//各スロットを比較
		for (int i = 0; i < (int)ChipID::ChipNum; i++)
		{
			if (group->Slot[i] != info->_ChipSlot[i])
			{
				isMatch = false;
			}
		}

		if (!isMatch)
		{
			//マッチングしていないので次へ.
			continue;
		}

		//パターン一致したのでID設定。
		pattern = group->GroupID;
		break;
	}

	return pattern;
}

/**
* オブジェクトを作成.
*
* @param location	場所ID.
* @param path		フォルダパス.
*/
void HistoryManager::_CreateObject(int location,const char * path)
{
	//CSVからオブジェクトの情報読み込み
	vector<unique_ptr<ObjectInfo>> objInfo;
	Support::LoadCSVData<ObjectInfo>(path, ObjectInfoData, ARRAY_SIZE(ObjectInfoData), objInfo);

	//情報からオブジェクト生成。
	for(short i = 0;i < objInfo.size();)
	{
		//コリジョンかどうか？
		if (strcmp(objInfo[i]->filename, "coll") != 0)
		{
			//オブジェクト生成
			ContinentObject* obj = INSTANCE(GameObjectManager)->AddNew<ContinentObject>("ContinentObject", 2);

			obj->transform->SetLocalPosition(objInfo[i]->pos);
			obj->transform->SetRotation(objInfo[i]->ang);
			objInfo[i]->sca.y *= -1.0f;
			obj->transform->SetLocalScale(objInfo[i]->sca);
			obj->LoadModel(objInfo[i]->filename);

			//管理用の配列に追加。
			if (location >= 0)
			{
				_GameObjectList[location].push_back(obj);
			}

			//次がコリジョンかどうか？
			while (true)
			{
				ObjectInfo* info;
				//範囲外チェック。
				try {
					info = objInfo.at(++i).get();
				}
				catch (std::out_of_range& ex) {
					break;
				}

				//名前チェック
				if (strcmp(info->filename, "coll") == 0)
				{
					//コリジョンを生成してゲームオブジェクトにアタッチ。
					BoxCollider* box = obj->AddComponent<BoxCollider>();
					RigidBody* coll = obj->AddComponent<RigidBody>();
					box->Create(Vector3(fabsf(info->sca.x), fabsf(info->sca.y), fabsf(info->sca.z)));
					RigidBodyInfo Rinfo;
					Rinfo.mass = 0.0f;
					Rinfo.coll = box;
					Rinfo.id = (const int)fbCollisionAttributeE::ALL;
					Rinfo.offset = info->pos;
					/*Quaternion q; /*q.SetEuler(info->ang);*/
					Quaternion q; /*q.SetRotation(Vector3::up, 180.0f);*/
					/*q.SetEuler(Vector3(0.0f, -90.0f, 0.0f));*/
					//q.SetEuler(Vector3(0.0f, 180.0f, 0.0f));
					q.SetRotation(Vector3::up, PI);
					q.Multiply(info->ang);
					Rinfo.rotation = q;
					coll->SetKinematick(true);
					coll->Create(Rinfo,false);
					//カメラと当たらないコリジョンかどうか？
					if((bool)info->hitcamera)
					{
						//コリジョンの属性に「カメラと当たらない」を追加する
						//未実装。
					}
				}else
				{
					break;
				}
			}
		}
	}

	objInfo.clear();
}

/**
* コリジョンを作成.
*
* @param location	場所ID.
* @param path		フォルダパス.
*/
void HistoryManager::_CreateCollision(int location, const char * path)
{
	//CSVから当たり判定の情報読み込み
	vector<unique_ptr<CollisionInfo>> colls;
	Support::LoadCSVData(path, CollisionInfoData, ARRAY_SIZE(CollisionInfoData), colls);

	//情報から当たり判定生成。
	FOR(i, colls.size())
	{
		//生成
		ContinentObject* coll = INSTANCE(GameObjectManager)->AddNew<ContinentObject>("StageCollision", 2);
		
		coll->transform->SetLocalPosition(colls[i]->pos);
		coll->transform->SetRotation(colls[i]->ang);
		coll->transform->SetLocalScale(colls[i]->sca);
		//管理用の配列に追加。
		if (location >= 0)
		{
			_GameObjectList[location].push_back(coll);
		}
	}

	colls.clear();
}
